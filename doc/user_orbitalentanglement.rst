Orbital entanglement analysis
#############################

.. contents::

.. _orbitalentanglement:

Orbital entanglement and orbital correlation
============================================


Supported features
==================

If not mentioned otherwise, the orbital entanglement module supports restricted orbitals, ``DenseLinalgFactory`` and ``CholeskyLinalgFactory``. The current version of Horton offers

1. Calculation of single-orbital entropy and orbital-pair mutual information for a :ref:`seniority-zero wavefunction <orbitalentanglementseniorityzero>`

Supported wavefunction models are

1. :ref:`AP1roG <introap1rog>` (seniority-zero wavefunction)


.. _orbitalentanglementseniorityzero:

Orbital entanglement and correlation for a seniority zero wavefunction
======================================================================

If you use this module, please cite [boguslawski2015a]_

How to set-up a calculation
---------------------------

First, create an instance of the ``OrbitalEntanglement`` class,

.. code-block:: python

    entanglement = OrbitalEntanglementAp1rog(lf, one_dm, two_dm)

with arguments

    :lf: A linear algebra factory. One of ``DenseLinalgFactory``, ``CholeskyLinalgFactory``
    :one_dm: (``OneIndex`` instance) the response 1-RDM
    :two_dm: (list of ``TwoIndex`` instances) the response 2-RDM. The first list element contains the :math:`\Gamma_{pp}^{qq}` block, while the second list element contains the :math:`\Gamma_{pq}^{pq}` block.

To calculate the single-orbital entropy and orbital-pair mutual information, use a function call,

.. code-block:: python

    entanglement()

By default, the single-orbital entropy and orbital-pair mutual information will be written to disk. The single-orbital entropy is stored in ``s1.dat``, while the orbital-pair mutual information is written to ``i12.dat``. ``s1.dat`` contains two columns, where the first column contains the orbital index and the second column the corresponding single-orbital entropy. ``i12.dat`` has 3 columns. The first two columns encode the orbital indices, while the third column contains the corresponding mutual information.

How to generate correlation diagrams
------------------------------------

Horton provides ``gnuplot`` scripts to generate the entanglement and correlation diagrams. All scripts are tested for ``gnuplot4.7``.

To generate the single-orbital entropy diagram, run

.. code-block:: bash

    build_so_entropy [init_index final_index]

where **init_index** and **final_index** are optional arguments. If provided, the single-orbital entropy will be plotted for orbital indices in the interval [init_index, final_index].

The orbital-pair mutual information plot can be generated by running

.. code-block:: bash

    build_mi cutoff [init_index final_index]

**cutoff** determines the lower cutoff value of the mutual information. Orbital correlations that are smaller than **cutoff** will not be displayed in the mutual information diagram. As above, **init_index** and **final_index** are optional arguments. If provided, the mutual information will be plotted for orbital indices in the interval [init_index, final_index].


Example input files
===================

Orbital entanglement analysis of an AP1roG wavefunction
-------------------------------------------------------

This is a basic example on how to perform an orbital entanglement analysis in Horton. This script performs an orbital-optimized AP1roG calculation, followed by an orbital entanglement analysis of the AP1roG wavefunction for the water molecule using the cc-pVDZ basis set.

.. code-block:: python

    from horton import *
    ###############################################################################
    ## Set up molecule, define basis set ##########################################
    ###############################################################################
    mol = Molecule.from_file('mol.xyz')
    obasis = get_gobasis(mol.coordinates, mol.numbers, 'cc-pvdz')
    ###############################################################################
    ## Define Occupation model, expansion coefficients and overlap ################
    ###############################################################################
    lf = DenseLinalgFactory(obasis.nbasis)
    occ_model = AufbauOccModel(5)
    moceoff = lf.create_expansion(obasis.nbasis)
    olp = obasis.compute_overlap(lf)
    ###############################################################################
    ## Construct Hamiltonian ######################################################
    ###############################################################################
    kin = obasis.compute_kinetic(lf)
    na = obasis.compute_nuclear_attraction(mol.coordinates, mol.pseudo_numbers, lf)
    er = obasis.compute_electron_repulsion(lf)
    external = {'nn': compute_nucnuc(mol.coordinates, mol.pseudo_numbers)}
    terms = [
        RTwoIndexTerm(kin, 'kin'),
        RDirectTerm(er, 'hartree'),
        RExchangeTerm(er, 'x_hf'),
        RTwoIndexTerm(na, 'ne'),
    ]
    ham = REffHam(terms, external)
    ###############################################################################
    ## Perform initial guess ######################################################
    ###############################################################################
    guess_core_hamiltonian(olp, kin, na, moceoff)
    ###############################################################################
    ## Do a Hartree-Fock calculation ##############################################
    ###############################################################################
    scf_solver = PlainSCFSolver(1e-6)
    scf_solver(ham, lf, olp, occ_model, moceoff)
    ###############################################################################
    ## Combine one-electron integrals to single Hamiltonian #######################
    ###############################################################################
    one = kin.copy()
    one.iadd(na)

    ###############################################################################
    ## Do OO-AP1roG optimization ##################################################
    ###############################################################################
    ap1rog = RAp1rog(lf, occ_model)
    energy, g, l = ap1rog(one, er, external['nn'], moceoff, olp, True)

    ###############################################################################
    ## Do orbital entanglement analysis ###########################################
    ###############################################################################
    one_dm = lf.create_one_index()
    one_dm.assign(exp_alpha.occupations)
    twoppqq = lf.create_two_index()
    twopqpq = lf.create_two_index()
    twoppqq.compute_2dm_ap1rog(one_dm, g, l, 'ppqq')
    twopqpq.compute_2dm_ap1rog(one_dm, g, l, 'pqpq')

    entanglement = OrbitalEntanglementAp1rog(lf, one_dm, [twoppqq,twopqpq])
    entanglement()
